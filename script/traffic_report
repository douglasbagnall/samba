#!/usr/bin/env python
#
# Copyright (C) Catalyst IT Ltd 2017
#
# Catalyst's contribution mostly by Douglas Bagnall
# <douglas.bagnall@catalyst.net.nz>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import sys
import os
import optparse
from collections import defaultdict
import re

sys.path.insert(0, "bin/python")

from samba.emulate import traffic_report
import samba.getopt as options

OUTPUT_DIR = None
POP_UP = False
#GRAPH_STYLE = 'ggplot'
GRAPH_STYLE = 'fivethirtyeight'
GRAPH_STYLE = 'bmh'
#GRAPH_STYLE = 'seaborn-white'

# DISTRIBUTED_DOTS tries to make things of similar colour differ in
# shape, so that you can tell them apart.

DISTRIBUTED_DOTS = {
    "cldap:3": '.',
    "drsuapi:0": '1',
    "drsuapi:1": '2',
    "drsuapi:12": '3',
    "drsuapi:13": '4',
    "ldap:0": '|',
    "ldap:3": '_',
    "lsarpc:15": '1',
    "lsarpc:76": '2',
    "lsarpc:77": '3',
    "nbns:0": '.',
    "rpc_netlogon:29": 'x',
    "rpc_netlogon:30": '4',
    "rpc_netlogon:39": '1',
    "rpc_netlogon:40": '2',
    "rpc_netlogon:45": '3',
    "samr:1": '_',
    "samr:3": '|',
    "samr:5": '+',
    "samr:6": 'x',
    "samr:7": '1',
    "samr:8": '2',
    "samr:16": '3',
    "samr:17": '4',
    "samr:18": '|',
    "samr:34": '_',
    "samr:36": '+',
    "samr:39": 'x',
    "samr:64": '1',
    "srvsvc:16": '|',
    "srvsvc:21": '_',
}


def import_matplotlib(we_have_x):
    global matplotlib, plt, cm, np, colourmap

    try:
        import matplotlib
    except ImportError:
        print ("This software requires the matplotlib library to draw graphs. "
               "It does not seem to be installed. Try without --graph-dir or "
               "--pop-up-graphs.")
        sys.exit(1)

    # If we don't have an X server, we need to divert matplotlib away
    # from using TK. 'Agg' allows it to draw images.
    if not we_have_x:
        matplotlib.use('Agg')

    import matplotlib.pyplot as plt
    from matplotlib import cm
    import numpy as np
    #matplotlib.rcParams.update({'font.size': 10,
    #                            'savefig.facecolor': '#ffffff',
    #                            'savefig.edgecolor': '#ffffff',
    #                            'figure.autolayout': True,
    #})
    #colourmap = cm.viridis
    colourmap = cm.gnuplot
    #colourmap = cm.jet
    plt.style.use(GRAPH_STYLE)
    matplotlib.rcParams.update({'font.size': 11})


def maybe_save_img(fig, filename):
    if OUTPUT_DIR is not None:
        fn = os.path.join(OUTPUT_DIR, filename)
    fig.set_size_inches(12, 12)
    plt.savefig(fn,
                dpi=100,
                #frameon=True,
                #pad_inches=1,
                #facecolor='#ffffff',
                #edgecolor='#ffffff'
    )


# a start-somewhere function
def draw_a_graph(data, basename=''):
    plot = plt.plot
    fig = plt.figure()
    conversations = defaultdict(list)
    for d in data:
        conversations[d.c_id].append(d.time)

    scale = 1.0 / len(conversations)
    colours = [colourmap(x * scale) for x in range(len(conversations))]

    for c, colour in zip(conversations.values(), colours):
        plot(c, '-', color=colour)
        plot(c, '.', color=colour)

    maybe_save_img(fig, "traffic-seaweed-%s.png" % basename)

    if POP_UP:
        plt.show()


def draw_time_vs_duration_by_types(data, basename='', log=False,
                                   dots={}, filter=''):
    if log:
        basename = '%s-log' % basename
        plot = plt.semilogy
    else:
        plot = plt.plot

    if filter:
        basename = '%s-%s' % (basename, re.sub('\W', '_', filter))
        accept = re.compile(filter).search
    else:
        def accept(x):
            return True

    fig = plt.figure()
    ax = plt.subplot2grid((3, 3), (0, 0), colspan=3, rowspan=2)

    packet_types = defaultdict(list)
    for d in data:
        if accept(d.proto):
            packet_types['%s:%s' % (d.proto, d.op_id)].append(
                (d.time, d.duration, d.success))

    n = len(packet_types)
    colours = [colourmap(x / float(n)) for x in range(n)]

    labels, values = dict_as_key_sorted_lists(packet_types)

    for k, v, colour in zip(labels, values, colours):
        s_x, s_y, f_x, f_y = [], [], [], []
        for t, d, succ in v:
            if succ:
                s_x.append(t)
                s_y.append(d)
            else:
                f_x.append(t)
                f_y.append(d)
        if s_x:
            plot(s_x, s_y, dots.get(k, '.'), color=colour,
                 label="%s (%d)" % (k, len(s_x)))
        if f_x:
            plot(f_x, f_y, 'd', color=colour,
                 label='%s error (%d)' % (k, len(f_x)))

    plt.legend(bbox_to_anchor=(0.0, -0.05, 1.0, -0.05),
               ncol=4,
               mode="expand",
               loc='upper left')
    maybe_save_img(fig, "traffic-scatter-%s.png" % basename)

    if POP_UP:
        plt.show()


def dict_as_key_sorted_lists(d):
    keys, values = [], []
    for k, v in sorted(d.items()):
        keys.append(k)
        values.append(v)
    return keys, values


def times_to_packet_durations(times):
    packet_types = defaultdict(list)
    for d in times:
        error = '' if d.success else ' error'
        packet_types['%s:%s%s' % (d.proto, d.op_id, error)].append(d.duration)
    return packet_types


def draw_traffic_type_boxplot(data, basename='', violin=False):
    if violin:
        plot = plt.violinplot
    else:
        plot = plt.boxplot
    fig = plt.figure()
    ax = fig.add_subplot(111)
    packet_types = times_to_packet_durations(data)

    labels, values = dict_as_key_sorted_lists(packet_types)

    plot(values)
    index = np.arange(len(labels))
    plt.xticks(index, labels)
    ax.set_xticklabels(labels,
                       rotation=-45, rotation_mode='anchor',
                       va='top', ha='left')
    if violin:
        maybe_save_img(fig, "traffic-types-violin-%s.png" % basename)
    else:
        maybe_save_img(fig, "traffic-types-%s.png" % basename)
    if POP_UP:
        plt.show()


def draw_comparison_of_versions(data, log=False):
    if log:
        plot = plt.semilogy
    else:
        plot = plt.plot

    fig, ax = plt.subplots()
    series = defaultdict(dict)
    basenames = []
    for filename, basename, times in data:
        basenames.append(basename)
        packet_types = times_to_packet_durations(times)
        for k, v in packet_types.items():
            bands = np.percentile(v, [9.0, 50.0, 91.0])
            series[k][basename] = bands

    for k, d in series.items():
        x, tops, medians, bottoms, labels = [], [], [], [], []
        for i, b in enumerate(basenames):
            if b in d:
                x.append(i)
                labels.append(b)
                tops.append(d[b][0])
                medians.append(d[b][1])
                bottoms.append(d[b][2])
            else:
                labels.append('')
        plot(x, medians, 'k', color='#cc0000')
        plot(x, medians, '.', color='#cc0000')
        plt.fill_between(x, bottoms, tops,
                         alpha=0.3,
                         #edgecolor='#ff0000',
                         facecolor='#ffcccc',
                         antialiased=True)

        index = np.arange(len(basenames))
        plt.xticks(index, labels)

        #ax.set_xticklabels(labels,
        #                   rotation=-45, rotation_mode='anchor',
        #                   va='top', ha='left')

        if POP_UP:
            plt.show()
        maybe_save_img(fig, "multi-%s%s-%s.png" %
                       (re.sub('\W', '-', k),
                        '-log' if log else '',
                        '-'.join(basenames)))
        plt.cla()


    print series['nbns:0']


def draw_histograms_of_durations(times, basename):
    fig, ax = plt.subplots()
    for k, v in times_to_packet_durations(times).items():
        plt.hist(v, bins=int(len(v) ** 0.5) + 20)
        if POP_UP:
            plt.show()
        maybe_save_img(fig, "histogram-%s-%s.png" %
                       (basename, re.sub('\W', '-', k)))
        plt.cla()


def draw_comparison_of_summaries(summaries, abs=False, only_common=True,
                                 logscale=False,
                                 name='traffic-summaries'):
    fig = plt.figure()
    ax = fig.add_subplot(111)

    data = {}
    basenames = []

    # this is getting fiddly
    totals = defaultdict(int)
    for filename, basename, packets in summaries:
        basenames.append(basename)
        d = defaultdict(int)
        data[basename] = d
        for p in packets:
            k = '%s:%s' % (p.proto, p.op_id)
            d[k] += 1
            totals[k] += 1

    common_keys = set(totals)
    for d in data.values():
        common_keys &= set(d)

    if only_common:
        for k in totals.keys():
            if k not in common_keys:
                del totals[k]

    # order keys by total counts
    keys, total_values = [], []
    for v, k in sorted(((v, k) for k, v in totals.items()), reverse=True):
        keys.append(k)
        total_values.append(v)

    index = np.arange(len(keys))
    bar_width = 0.8 / len(data)
    colours = [colourmap(x / float(len(data)))
               for x in range(len(data))]

    i = 0
    for basename, d in data.items():
        colour = colours[i]
        values = [d[k] for k in keys]
        if not abs:
            common_values = [d[k] for k in common_keys]
            vsum = float(sum(common_values)) or 1.0
            values = [x / vsum for x in values]

        ax.bar(index + i * bar_width, values, bar_width,
               color=colour, log=logscale,
               label='%s' % basename)
        i += 1

    plt.xticks(index + bar_width / 2, keys)
    ax.set_xticklabels(keys,
                       rotation=-45, rotation_mode='anchor',
                       va='top', ha='left')

    plt.legend()
    maybe_save_img(fig, "%s-%s.png" % (name, '-'.join(basenames)))
    if POP_UP:
        plt.show()


def main():
    parser = optparse.OptionParser(
        ("%s [options] <timing-file> [<timing-file> [<timing-file>...]]" %
         sys.argv[0]))

    sambaopts = options.SambaOptions(parser)
    parser.add_option_group(options.VersionOptions(parser))
    parser.add_option('-G', '--graph-dir', default=None,
                      help='put graph images in this directory')
    parser.add_option('--pop-up-graphs', action="store_true", default=False,
                      help='show graphs directly in GUI if possible')

    parser.add_option('--summaries', action="store_true",
                      help='the input files are traffic summaries')

    opts, args = parser.parse_args()

    global OUTPUT_DIR, POP_UP, np
    OUTPUT_DIR = opts.graph_dir
    POP_UP = opts.pop_up_graphs

    try:
        import numpy as np
        have_numpy = True
    except ImportError as e:
        print ("WARNING: this software requires the numpy library for "
               "detailed analysis, but it does not seem to be "
               "installed. Only basic reports wil be available.")
        have_numpy = False

    if opts.pop_up_graphs or opts.graph_dir is not None:
        we_have_x = 'DISPLAY' in os.environ
        if not we_have_x and opts.pop_up_graphs:
            print ("--pop-up-graphs supplied, but no X server detected. "
                   "Eith you have some exotic windowing system, or failure is "
                   "imminent. Let's see.")
        import_matplotlib(opts.pop_up_graphs)

    data = []

    try:
        for filename in args:
            f = open(filename)
            basename = re.sub(r'\W', '_', os.path.basename(filename))
            if opts.summaries:
                parser = traffic_report.summary_parser
            else:
                parser = traffic_report.get_file_parser(f.next())
            data.append((filename,
                         basename,
                         [parser(line) for line in f]))
            f.close()

    except IOError as e:
        print "Could not read %s: %s" % (filename, e)
        sys.exit(1)

    if opts.summaries:
        draw_comparison_of_summaries(data)
        draw_comparison_of_summaries(data, False, False, False,
                                     "traffic-summaries-all")
        draw_comparison_of_summaries(data, False, True, True,
                                     "traffic-summaries-log")
        draw_comparison_of_summaries(data, False, False, True,
                                     "traffic-summaries-log-all")
        draw_comparison_of_summaries(data, True, True, False,
                                     "traffic-summaries-abs")

        sys.exit()

    if len(data) > 1:
        print "looking at %d files" % len(data)
        draw_comparison_of_versions(data)
        draw_comparison_of_versions(data, log=True)
        sys.exit()

    for filename, basename, times in data:
        draw_traffic_type_boxplot(times, basename=basename)
        draw_traffic_type_boxplot(times, basename=basename, violin=True)
        draw_time_vs_duration_by_types(times, basename=basename,
                                       dots=DISTRIBUTED_DOTS)
        draw_time_vs_duration_by_types(times, basename=basename,
                                       log=True, dots=DISTRIBUTED_DOTS)
        for family in ('ldap',
                       "drsuapi",
                       "lsarpc",
                       "nbns",
                       "rpc_netlogon",
                       "samr",
                       "srvsvc"):
            draw_time_vs_duration_by_types(times, basename=basename,
                                           log=False, filter=family)
            draw_time_vs_duration_by_types(times, basename=basename,
                                           log=True, filter=family)

        draw_histograms_of_durations(times, basename)


main()
